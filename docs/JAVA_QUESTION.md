# 자바 핵심 개념 정리

<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">

| 원시 타입   | 크기   |
|---------|------|
| byte    | 1바이트 |
| char    | 2바이트 |
| short   | 2바이트 |
| int     | 4바이트 |
| long    | 8바이트 |
| float   | 4바이트 |
| double  | 8바이트 |
| boolean | 1바이트 |

</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">

`오버라이딩`

- 정의: 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것
- 조건:
    - 선언부가 부모 클래스의 메소드와 동일해야 함 (리턴 타입의 경우, 부모 클래스의 리턴 타입으로 변환할 수 있는 타입이라면 사용 가능)
    - 접근 제어자를 부모 클래스의 메소드보다 더 좁은 범위로 설정할 수 없음
    - 예외를 부모 클래스의 메소드보다 더 큰 범위로 선언할 수 없음

`오버로딩`

- 정의: 한 클래스에 매개변수가 다른 메소드를 같은 이름으로 여러 개 선언하는 것
- 조건:
    - 메소드의 이름이 같아야 함
    - 매개변수의 개수 또는 타입이 달라야 함

</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">

- 정의: 프로그램을 **객체들의 결합**으로 바라보는 프로그래밍 패러다임
    - 객체는 특정한 역할을 수행하며 서로 상호작용하는 프로그램의 작은 단위라고 볼 수 있음
- 주요 특징 4가지:
    1. 추상화
        - 객체들의 공통적인, 본질적인 기능 또는 속성을 추출해 정의하는 것
        - 객체가 수행해야 하는 핵심적인 **역할**의 정의(인터페이스)와 실제 **구현**(클래스)으로 객체를 분리할 수 있음
    2. 상속
        - 상위 클래스를 상속 받는 하위 클래스가 상위 클래스의 기능과 속성을 재사용하며 확장하는 것
        - 코드의 반복을 줄일 수 있고, 수정이 용이함
    3. 다형성
        - 객체의 기능 또는 속성이 상황에 따라 다른 형태를 갖는 것 (ex: 오버라이딩, 오버로딩)
          <br>→ 한 타입의 참조 변수를 통해 여러 타입의 객체를 참조할 수 있는 것 (→ 상위 클래스 타입 변수로 여러 하위 클래스 객체를 참조)
        - 프로그램이 유연해지고, 변경과 확장이 용이함
    4. 캡슐화
        - 객체의 기능과 속성들을 하나의 캡슐로 만들어 외부로부터 보호하는 것
        - 접근 제어자를 이용해 구현
        - 객체의 독립성을 보장하고, 객체 간 결합도를 낮춤

</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">

`추상 클래스`

- 정의: 하나 이상의 추상 메소드를 포함하는 클래스
    - 추상 메소드: 선언부만 존재하여 자식 클래스에서 반드시 구현해야 하는 메소드
- 특징:
    - 인스턴스를 생성할 수 없음
    - **추상 메소드 외에 생성자, 필드, 일반 메소드를 포함할 수 있음**

`인터페이스`

- 정의: 객체가 수행해야 하는 핵심적인 역할만을 정의한 틀
- 특징:
    - 인스턴스를 생성할 수 없음
    - 모든 필드가 `public static final`이어야 함 (상수)
    - 모든 메소드가 `public abstract`이어야 함 (추상 메소드)
    - 구현 클래스에서 **다중 상속(구현)이 가능함**
        - _클래스는 다중 상속이 불가능_

</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">

- 정의: 자바가 사용되지 않는 메모리를 정리해 주는 작업
    - JVM 내의 가비지 컬렉터가 GC를 수행함
- 장점: 개발자가 직접 메모리를 관리하지 않아도 됨

</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">

자바 클래스파일(바이트 코드)를 실행했을 때, JVM이 동작하기 시작함

1. 클래스 로더가 클래스(바이트 코드)를 JVM 내의 런타임 데이터 영역(메소드, 힙 영역)으로 로딩함
    - JVM에서의 애플리케이션 동작은 로딩, 링크, 초기화 수행 후 메인 메소드를 실행하는 것 (다른 클래스의 로딩, 링크, 초기화는 동적으로 수행됨)
2. 자바 인터프리터가 바이트 코드를 한 줄씩 읽고 OS가 실행할 수 있는 기계어로 번역함
3. JIT 컴파일러가 자주 사용되는 코드를 기계어로 번역한 후 캐시에 컴파일해둠
    - 인터프리터가 기본으로 동작하고, JIT는 자주 사용되는 코드만 캐싱해서 속도를 보완함

</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">

`불변객체`

- 정의: 생성 후 상태를 바꿀 수 없는 객체
    - 생성 시점 또는 실제로 사용되는 순간 초기화되고 이후 수정이 불가능함
- 장점:
    - 해당 객체를 참조할 때 모두 동일한 하나의 객체를 참조하게 됨
    - 데이터를 안전하게 보호할 수 있음
    - 수정이 불가능하기 때문에 동기화를 고려하지 않아도 됨 → Thread-safe + 성능 향상

`final`

1. final 필드(변수)
    - 값을 수정할 수 없는 필드 → 초기화 필수
        - 지역 변수의 경우 선언하는 시점이나 사용하기 전에 초기화
        - 멤버 필드의 경우 필드를 정의할 때 초기화하거나 생성자나 초기화 블록을 이용해서 초기화 (static인 경우에는 생성자로 초기화할 수 없음)
    - 참조 변수의 경우, 참조값(참조하는 객체)이 변경 불가. 참조하는 객체 내부의 값은 변경 가능함

2. final 메소드
    - 오버라이드할 수 없는 메소드

3. final 클래스
    - 상속할 수 없는 클래스

</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">

자바의 메모리 영역은 3가지로 구분됨

1. **메소드 영역 Method Area**
    - 클래스에 대한 정보가 저장되는 공간
    - 정적 변수, 정적 메소드 등이 저장됨
2. **힙 영역 Heap Area**
    - 생성된 인스턴스 객체가 저장되는 공간
3. **스택 영역 Stack Area**
    - 메소드 호출 시 할당되는 공간
    - 실행 중인 메소드의 지역 변수, 매개변수 등이 저장됨
    - 메소드 실행이 끝나면 반환됨

</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">

`new String()`

- 항상 새로운 `String` 객체를 생성함 → 항상 다른 주소값이 리턴됨

`문자열 리터럴`

- 한 번 선언된 문자열이라면 존재하던 문자열 객체를 참조함(없는 경우에는 새로 생성) → 같은 문자열이면 동일한 주소값이 리턴됨

</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">

- 정의: 메소드를 이름 없이 하나의 식으로 표현한 것. 익명 함수라고도 함
- 사용법: `(parameter) -> { body }`
    - 매개변수의 타입이 추론 가능한 경우 생략 가능
    - 매개변수가 하나인 경우 소괄호 생략 가능
    - 바디가 한 줄인 경우 중괄호 생략 가능(세미콜론도 붙이지 않음). 단, return 문만 있는 경우 괄호를 생략할 수 없음
    - 바디가 표현식인 경우 표현식의 결과가 리턴값이
- 장점:
    - 클래스 작성과 객체 생성 없이 메소드를 사용할 수 있음 → 불필요한 코드 제거 + 가독성 향상
    - 다중 CPU를 활용하는 형태로 구현됨 → 병렬 프로그래밍이 용이
    - 지연 연산을 수행 → 성능 향상
- 단점:
    - 디버깅이 어려움
    - 재귀에 부적합함
    - 지나치게 사용하면 오히려 가독성을 떨어뜨림
    - 단순하게 원소를 순회하는 것은 람다식이 더 느림

</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">

`스트림 Stream`

- 정의: 연속된 데이터의 흐름. 입출력 장치와 프로그램 간의 연결 통로
- 특징:
    - 단방향이므로 `InputStream`, `OutputStream` 두 개를 별도로 사용
    - 연속적이므로 입출력이 진행되는 동안 다른 작업이 불가능 (Blocking 상태)
    - 바이트 단위로 처리하는 바이트 스트림과 문자(2바이트) 단위로 처리하는 문자 스트림으로 나뉨 (→ 이를 상속 받아 추가로 편리한 기능을 제공하는 보조 스트림도 있음)

`Stream API`

- 정의: 배열, 컬렉션, 파일 등에 저장된 많은 양의 데이터를 편리하게 다루는 방법을 제공하는 API
- 특징:
    - 저장되지 않고 필요할 때만 생성해 사용
    - 재사용이 불가능함
    - 원본 데이터를 변경하지 않음 (변경된 결과를 갖는 새 스트림이 반환됨)
    - 지연 연산을 수행해서 성능 향상에 도움이 됨
    - 병렬 처리가 쉬움 (`parallelStream()` 사용 시)
- 사용법: `데이터.스트림생성().중간연산().최종연산()`
    - 데이터: 배열, 컬렉션, 문자열, 람다식, 파일 등에서 스트림을 생성할 수 있음
    - 스트림 생성: `stream()`, `chars()`, `lines()` 등
    - 중간 연산은 여러 개 연결해서 사용 가능 (대표적 예시: `filter()`, `map()`, `sorted()` 등)
    - 최종 연산의 대표적 예시: `forEach()`, `findAny()` 등

</div>
</details>
<br>
